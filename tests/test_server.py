"""Tests for the MCP server tool functions."""

import json
from unittest.mock import patch, MagicMock
import pytest
from pathlib import Path

import openacr_mcp.server as srv
from openacr_mcp.acr_client import AcrClient, AcrResult

OPENACR_DIR = Path.home() / "openacr"
skip_no_openacr = pytest.mark.skipif(
    not (OPENACR_DIR / "bin" / "acr").exists(),
    reason="OpenACR not installed at ~/openacr",
)


@skip_no_openacr
class TestServerTools:
    """Integration tests that call tool functions directly (not via MCP protocol)."""

    @pytest.fixture(autouse=True)
    def setup_client(self):
        """Initialize the global client for tool functions."""
        srv._client = AcrClient(OPENACR_DIR)
        yield
        srv._client = None

    def test_list_namespaces(self):
        result = json.loads(srv.list_namespaces())
        assert result["ok"] is True
        assert result["count"] > 0
        ns_names = [r["ns"] for r in result["records"]]
        assert "algo" in ns_names

    def test_get_namespace_tree(self):
        result = json.loads(srv.get_namespace_tree("dev"))
        assert result["ok"] is True
        assert result["namespace"] == "dev"
        # Tree should contain ctypes, fields, and fconsts
        tree = result["tree"]
        assert "dmmeta.ctype  ctype:dev.Mdmark" in tree
        assert "dmmeta.field  field:dev.Mdmark.mdmark" in tree
        assert "dmmeta.fconst" in tree
        assert "dmmeta.ssimfile" in tree

    def test_get_namespace_tree_unknown(self):
        result = json.loads(srv.get_namespace_tree("nonexistent_ns_xyz"))
        # acr returns ok with empty output for unknown namespaces
        assert result["ok"] is True
        assert "tree" in result

    def test_list_ctypes(self):
        result = json.loads(srv.list_ctypes("algo"))
        assert result["ok"] is True
        assert result["count"] > 0

    def test_get_ctype(self):
        result = json.loads(srv.get_ctype("algo.Bool"))
        assert result["ok"] is True
        assert "algo.Bool" in result["tree"]

    def test_list_fields(self):
        result = json.loads(srv.list_fields("algo.Bool"))
        assert result["ok"] is True
        assert result["count"] >= 1

    def test_query(self):
        result = json.loads(srv.query("dmmeta.ns:algo"))
        assert result["ok"] is True
        assert result["count"] == 1

    def test_search(self):
        result = json.loads(srv.search("Bool"))
        assert result["ctype_count"] > 0 or result["field_count"] > 0

    def test_list_generated_headers(self):
        result = json.loads(srv.list_generated_headers("algo"))
        assert result["count"] >= 1
        assert any("algo_gen.h" in h for h in result["headers"])

    def test_get_generated_code(self):
        result = json.loads(srv.get_generated_code("include/gen/algo_gen.h"))
        assert "content" in result
        assert "Generated by AMC" in result["content"]

    def test_get_generated_code_not_found(self):
        result = json.loads(srv.get_generated_code("include/gen/nonexistent_gen.h"))
        assert "error" in result

    def test_get_functions(self):
        result = json.loads(srv.get_functions("algo"))
        assert result["total_enums"] > 0
        assert result["total_structs"] > 0
        assert result["total_functions"] > 0

    def test_get_functions_unknown_ns(self):
        result = json.loads(srv.get_functions("nonexistent"))
        assert "error" in result


class TestServerToolsNoClient:
    """Test that tools handle missing client gracefully."""

    @pytest.fixture(autouse=True)
    def clear_client(self):
        srv._client = None
        yield

    def test_list_namespaces_no_client(self):
        result = json.loads(srv.list_namespaces())
        assert "error" in result

    def test_query_no_client(self):
        result = json.loads(srv.query("dmmeta.ns:%"))
        assert "error" in result

    def test_create_target_no_client(self):
        result = json.loads(srv.create_target("test", "ssimdb"))
        assert "error" in result


class TestGetWorkflowGuide:
    """Tests for the get_workflow_guide tool (no client needed)."""

    def test_returns_valid_json(self):
        result = json.loads(srv.get_workflow_guide())
        assert "workflows" in result
        assert "arg_types_reference" in result
        assert "reftype_reference" in result

    def test_has_expected_workflow_sections(self):
        result = json.loads(srv.get_workflow_guide())
        titles = [w["title"] for w in result["workflows"]]
        assert "Create a new ssimdb with types" in titles
        assert "Add an enum type" in titles
        assert "Create a struct with foreign key references" in titles
        assert "Create an exe that uses a ssimdb" in titles

    def test_arg_types_has_categories(self):
        result = json.loads(srv.get_workflow_guide())
        arg_types = result["arg_types_reference"]
        assert "strings" in arg_types
        assert "integers" in arg_types
        assert "other" in arg_types
        assert "algo.cstring" in arg_types["strings"]
        assert "u32" in arg_types["integers"]

    def test_reftype_reference_has_key_types(self):
        result = json.loads(srv.get_workflow_guide())
        reftypes = result["reftype_reference"]
        assert "Val" in reftypes
        assert "Pkey" in reftypes
        assert "Base" in reftypes
        assert "Thash" in reftypes

    def test_each_workflow_has_steps(self):
        result = json.loads(srv.get_workflow_guide())
        for workflow in result["workflows"]:
            assert "title" in workflow
            assert "steps" in workflow
            assert len(workflow["steps"]) >= 2


class TestCreateTarget:
    """Unit tests for create_target tool (mocked client)."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_calls_acr_ed_create_target(self):
        self.mock_client.acr_ed_create_target.return_value = AcrResult(ok=True)
        result = json.loads(srv.create_target("mydb", "ssimdb", "My database"))
        assert result["ok"] is True
        self.mock_client.acr_ed_create_target.assert_called_once_with(
            "mydb", "ssimdb", "My database"
        )

    def test_rejects_invalid_nstype(self):
        result = json.loads(srv.create_target("mydb", "invalid_type"))
        assert "error" in result
        assert "invalid_type" in result["error"]
        self.mock_client.acr_ed_create_target.assert_not_called()

    def test_valid_nstypes(self):
        for nstype in ("ssimdb", "exe", "lib", "protocol"):
            self.mock_client.acr_ed_create_target.return_value = AcrResult(ok=True)
            result = json.loads(srv.create_target("test", nstype))
            assert result["ok"] is True

    def test_propagates_error(self):
        self.mock_client.acr_ed_create_target.return_value = AcrResult(
            ok=False, stderr="namespace already exists", returncode=1
        )
        result = json.loads(srv.create_target("algo", "ssimdb"))
        assert result["ok"] is False
        assert "error" in result


class TestCamelToSnake:
    """Tests for the _camel_to_snake helper."""

    def test_simple(self):
        assert srv._camel_to_snake("Genre") == "genre"

    def test_two_words(self):
        assert srv._camel_to_snake("ReadingStatus") == "reading_status"

    def test_three_words(self):
        assert srv._camel_to_snake("OrderLineItem") == "order_line_item"

    def test_already_lower(self):
        assert srv._camel_to_snake("status") == "status"

    def test_acronym(self):
        assert srv._camel_to_snake("HTMLParser") == "html_parser"


class TestCreateCtypeAutoSsimfile:
    """Unit tests for create_ctype's auto-ssimfile and cfmt behavior."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_ssimdb_auto_creates_ssimfile_and_cfmt(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        self.mock_client.get_ns_type.return_value = "ssimdb"
        self.mock_client.acr_insert.return_value = AcrResult(ok=True)
        self.mock_client.amc.return_value = AcrResult(ok=True)

        result = json.loads(srv.create_ctype("mydb", "MyRecord", "A record"))
        assert result["ok"] is True
        assert result["ssimfile_auto_created"] is True
        assert result["cfmt_auto_created"] is True

        # Verify both ssimfile and cfmt were inserted
        calls = self.mock_client.acr_insert.call_args_list
        assert len(calls) == 2
        assert "dmmeta.ssimfile  ssimfile:mydb.my_record  ctype:mydb.MyRecord" in calls[0][0][0]
        assert "dmmeta.cfmt  cfmt:mydb.MyRecord.String" in calls[1][0][0]
        assert "read:Y" in calls[1][0][0]
        assert "print:Y" in calls[1][0][0]
        # Verify amc was re-run
        self.mock_client.amc.assert_called_once()

    def test_ssimdb_camel_case_conversion(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        self.mock_client.get_ns_type.return_value = "ssimdb"
        self.mock_client.acr_insert.return_value = AcrResult(ok=True)
        self.mock_client.amc.return_value = AcrResult(ok=True)

        srv.create_ctype("mydb", "ReadingStatus")

        calls = self.mock_client.acr_insert.call_args_list
        assert "dmmeta.ssimfile  ssimfile:mydb.reading_status  ctype:mydb.ReadingStatus" in calls[0][0][0]

    def test_exe_namespace_no_ssimfile(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        self.mock_client.get_ns_type.return_value = "exe"

        result = json.loads(srv.create_ctype("myapp", "Config"))
        assert result["ok"] is True
        self.mock_client.acr_insert.assert_not_called()

    def test_ssimfile_insert_failure(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        self.mock_client.get_ns_type.return_value = "ssimdb"
        self.mock_client.acr_insert.return_value = AcrResult(
            ok=False, stderr="duplicate record", returncode=1
        )

        result = json.loads(srv.create_ctype("mydb", "Dup"))
        assert "error" in result
        assert "ssimfile insert failed" in result["error"]

    def test_cfmt_insert_failure(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        self.mock_client.get_ns_type.return_value = "ssimdb"
        # ssimfile succeeds, cfmt fails
        self.mock_client.acr_insert.side_effect = [
            AcrResult(ok=True),
            AcrResult(ok=False, stderr="cfmt error", returncode=1),
        ]

        result = json.loads(srv.create_ctype("mydb", "Bad"))
        assert "error" in result
        assert "cfmt insert failed" in result["error"]


class TestCreateFconstUnit:
    """Unit tests for create_fconst using acr_insert."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_calls_acr_insert(self):
        self.mock_client.acr_insert.return_value = AcrResult(ok=True)
        result = json.loads(srv.create_fconst("mydb.Status.status", "active", "Active"))
        assert result["ok"] is True
        assert result["fconst"] == "mydb.Status.status/active"
        self.mock_client.acr_insert.assert_called_once()
        call_arg = self.mock_client.acr_insert.call_args[0][0]
        assert "fconst:mydb.Status.status/active" in call_arg

    def test_propagates_error(self):
        self.mock_client.acr_insert.return_value = AcrResult(
            ok=False, stderr="field not found", returncode=1
        )
        result = json.loads(srv.create_fconst("bad.Field.x", "val"))
        assert result["ok"] is False
        assert "error" in result


class TestCreateFinput:
    """Unit tests for create_finput tool."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_calls_acr_ed_create(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        result = json.loads(srv.create_finput("myapp", "mydb.my_table"))
        assert result["ok"] is True
        self.mock_client.acr_ed_create.assert_called_once()
        call_args = self.mock_client.acr_ed_create.call_args[0][0]
        assert "-finput" in call_args
        assert "-target" in call_args
        assert "myapp" in call_args
        assert "-ssimfile" in call_args
        assert "mydb.my_table" in call_args
        assert "-indexed" not in call_args

    def test_indexed_flag(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        result = json.loads(srv.create_finput("myapp", "mydb.my_table", indexed=True))
        assert result["ok"] is True
        call_args = self.mock_client.acr_ed_create.call_args[0][0]
        assert "-indexed" in call_args

    def test_propagates_error(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(
            ok=False, stderr="ssimfile not found", returncode=1
        )
        result = json.loads(srv.create_finput("myapp", "bad.table"))
        assert result["ok"] is False
        assert "error" in result


class TestCreateGstatic:
    """Unit tests for create_gstatic tool."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_calls_acr_ed_create(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        result = json.loads(srv.create_gstatic("myapp", "mydb.country"))
        assert result["ok"] is True
        call_args = self.mock_client.acr_ed_create.call_args[0][0]
        assert "-gstatic" in call_args
        assert "-target" in call_args
        assert "myapp" in call_args
        assert "-ssimfile" in call_args
        assert "mydb.country" in call_args

    def test_propagates_error(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(
            ok=False, stderr="target not found", returncode=1
        )
        result = json.loads(srv.create_gstatic("bad", "bad.table"))
        assert result["ok"] is False


class TestCreateFieldXref:
    """Unit tests for create_field xref/hashfld/sortfld/cascdel options."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_xref_with_hashfld(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        result = json.loads(srv.create_field(
            "myapp.FDb", "ind_order", "myapp.Order", "Thash",
            xref=True, via="myapp.Order/order",
            hashfld="myapp.Order.order",
        ))
        assert result["ok"] is True
        call_args = self.mock_client.acr_ed_create.call_args[0][0]
        assert "-xref" in call_args
        assert "-via" in call_args
        assert "myapp.Order/order" in call_args
        assert "-hashfld" in call_args
        assert "myapp.Order.order" in call_args

    def test_sortfld(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        srv.create_field(
            "myapp.FDb", "bh_order", "myapp.Order", "Bheap",
            xref=True, sortfld="myapp.Order.price",
        )
        call_args = self.mock_client.acr_ed_create.call_args[0][0]
        assert "-sortfld" in call_args
        assert "myapp.Order.price" in call_args

    def test_cascdel(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        srv.create_field("myapp.Order", "items", "myapp.Item", "Lary", cascdel=True)
        call_args = self.mock_client.acr_ed_create.call_args[0][0]
        assert "-cascdel" in call_args

    def test_before(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        srv.create_field(
            "myapp.Order", "priority", "u32", "Val",
            before="myapp.Order.status",
        )
        call_args = self.mock_client.acr_ed_create.call_args[0][0]
        assert "-before" in call_args
        assert "myapp.Order.status" in call_args

    def test_no_xref_flags_by_default(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        srv.create_field("myapp.Order", "name", "algo.cstring", "Val")
        call_args = self.mock_client.acr_ed_create.call_args[0][0]
        assert "-xref" not in call_args
        assert "-via" not in call_args
        assert "-hashfld" not in call_args
        assert "-sortfld" not in call_args
        assert "-cascdel" not in call_args
        assert "-before" not in call_args


class TestCreateSubstrField:
    """Unit tests for create_substr_field tool."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_calls_acr_ed_create(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        result = json.loads(srv.create_substr_field(
            "mydb.Review", "movie", ".LL", "mydb.Review.review", "Movie part of composite key",
        ))
        assert result["ok"] is True
        call_args = self.mock_client.acr_ed_create.call_args[0][0]
        assert "-field" in call_args
        assert "mydb.Review.movie" in call_args
        assert "-substr" in call_args
        assert ".LL" in call_args
        assert "-srcfield" in call_args
        assert "mydb.Review.review" in call_args

    def test_right_component(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        srv.create_substr_field(
            "mydb.Review", "reviewer", ".LR", "mydb.Review.review",
        )
        call_args = self.mock_client.acr_ed_create.call_args[0][0]
        assert ".LR" in call_args

    def test_propagates_error(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(
            ok=False, stderr="ctype not found", returncode=1
        )
        result = json.loads(srv.create_substr_field("bad.Type", "x", ".LL", "bad.Type.y"))
        assert result["ok"] is False


class TestCreateBitfield:
    """Unit tests for create_bitfield tool."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_calls_acr_ed_create(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(ok=True)
        self.mock_client.acr_insert.return_value = AcrResult(ok=True)
        result = json.loads(srv.create_bitfield(
            "myns.Header", "version", "u8", "myns.Header.flags", width=4, comment="Protocol version",
        ))
        assert result["ok"] is True
        assert result["field"] == "myns.Header.version"
        assert result["width"] == 4
        # Verify acr_ed -create was called with Bitfld reftype
        call_args = self.mock_client.acr_ed_create.call_args[0][0]
        assert "-reftype" in call_args
        idx = call_args.index("-reftype")
        assert call_args[idx + 1] == "Bitfld"
        assert "-srcfield" in call_args
        assert "myns.Header.flags" in call_args

    def test_create_failure(self):
        self.mock_client.acr_ed_create.return_value = AcrResult(
            ok=False, stderr="field exists", returncode=1
        )
        result = json.loads(srv.create_bitfield("myns.X", "y", "u8", "myns.X.f"))
        assert result["ok"] is False


class TestValidateSchema:
    """Unit tests for validate_schema tool."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_passes(self):
        self.mock_client.acr_check.return_value = AcrResult(ok=True)
        result = json.loads(srv.validate_schema())
        assert result["ok"] is True
        assert result["pattern"] == "%"
        self.mock_client.acr_check.assert_called_once_with("%")

    def test_scoped_pattern(self):
        self.mock_client.acr_check.return_value = AcrResult(ok=True)
        result = json.loads(srv.validate_schema("dmmeta.ctype:myns.%"))
        assert result["ok"] is True
        self.mock_client.acr_check.assert_called_once_with("dmmeta.ctype:myns.%")

    def test_reports_errors(self):
        self.mock_client.acr_check.return_value = AcrResult(
            ok=False,
            stderr="acr.badrefs  ctype:myns.Bad  field:myns.Bad.x  error:broken FK\n"
                   "acr.badrefs  ctype:myns.Bad  field:myns.Bad.y  error:missing ref\n",
            returncode=1,
        )
        result = json.loads(srv.validate_schema("dmmeta.ctype:myns.%"))
        assert result["ok"] is False
        assert result["error_count"] == 2
        assert len(result["errors"]) == 2

    def test_no_client(self):
        srv._client = None
        result = json.loads(srv.validate_schema())
        assert "error" in result


class TestListFconsts:
    """Unit tests for list_fconsts tool."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_namespace_query(self):
        self.mock_client.acr.return_value = AcrResult(ok=True, records=[
            {"_type": "dmmeta.fconst", "fconst": "dev.Mdmark.mdmark/CMD", "value": "CMD"},
        ])
        result = json.loads(srv.list_fconsts("dev"))
        assert result["ok"] is True
        assert result["count"] == 1
        self.mock_client.acr.assert_called_once_with("dmmeta.fconst:dev.%")

    def test_ctype_query(self):
        self.mock_client.acr.return_value = AcrResult(ok=True, records=[])
        srv.list_fconsts("dev", ctype="dev.Mdmark")
        self.mock_client.acr.assert_called_once_with("dmmeta.fconst:dev.Mdmark.%")

    def test_no_client(self):
        srv._client = None
        result = json.loads(srv.list_fconsts("dev"))
        assert "error" in result


class TestListSsimfiles:
    """Unit tests for list_ssimfiles tool."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_queries_namespace(self):
        self.mock_client.acr.return_value = AcrResult(ok=True, records=[
            {"_type": "dmmeta.ssimfile", "ssimfile": "dev.target"},
        ])
        result = json.loads(srv.list_ssimfiles("dev"))
        assert result["ok"] is True
        self.mock_client.acr.assert_called_once_with("dmmeta.ssimfile:dev.%")

    def test_no_client(self):
        srv._client = None
        result = json.loads(srv.list_ssimfiles("dev"))
        assert "error" in result


class TestListFinputs:
    """Unit tests for list_finputs tool."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_queries_target(self):
        self.mock_client.acr.return_value = AcrResult(ok=True, records=[
            {"_type": "dmmeta.finput", "field": "acr.FDb.ctype"},
        ])
        result = json.loads(srv.list_finputs("acr"))
        assert result["ok"] is True
        self.mock_client.acr.assert_called_once_with("dmmeta.finput:acr.%")

    def test_no_client(self):
        srv._client = None
        result = json.loads(srv.list_finputs("acr"))
        assert "error" in result


class TestGetDownstream:
    """Unit tests for get_downstream tool."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_default_level(self):
        self.mock_client.acr_ndown.return_value = AcrResult(ok=True, records=[
            {"_type": "dmmeta.ctype", "ctype": "dev.Builddir"},
            {"_type": "dmmeta.field", "field": "dev.Builddir.builddir"},
        ])
        result = json.loads(srv.get_downstream("dmmeta.ctype:dev.Builddir"))
        assert result["ok"] is True
        assert result["count"] == 2
        self.mock_client.acr_ndown.assert_called_once_with("dmmeta.ctype:dev.Builddir", 1)

    def test_custom_levels(self):
        self.mock_client.acr_ndown.return_value = AcrResult(ok=True, records=[])
        srv.get_downstream("dmmeta.ctype:dev.Builddir", levels=3)
        self.mock_client.acr_ndown.assert_called_once_with("dmmeta.ctype:dev.Builddir", 3)

    def test_clamps_levels(self):
        self.mock_client.acr_ndown.return_value = AcrResult(ok=True, records=[])
        srv.get_downstream("dmmeta.ctype:dev.Builddir", levels=999)
        self.mock_client.acr_ndown.assert_called_once_with("dmmeta.ctype:dev.Builddir", 100)

    def test_no_client(self):
        srv._client = None
        result = json.loads(srv.get_downstream("dmmeta.ctype:dev.Builddir"))
        assert "error" in result


class TestGetUpstream:
    """Unit tests for get_upstream tool."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_default_level(self):
        self.mock_client.acr_nup.return_value = AcrResult(ok=True, records=[
            {"_type": "dmmeta.ns", "ns": "dev"},
            {"_type": "dmmeta.ctype", "ctype": "dev.Builddir"},
        ])
        result = json.loads(srv.get_upstream("dmmeta.ctype:dev.Builddir"))
        assert result["ok"] is True
        assert result["count"] == 2
        self.mock_client.acr_nup.assert_called_once_with("dmmeta.ctype:dev.Builddir", 1)

    def test_custom_levels(self):
        self.mock_client.acr_nup.return_value = AcrResult(ok=True, records=[])
        srv.get_upstream("dmmeta.field:dev.Builddir.builddir", levels=2)
        self.mock_client.acr_nup.assert_called_once_with("dmmeta.field:dev.Builddir.builddir", 2)

    def test_no_client(self):
        srv._client = None
        result = json.loads(srv.get_upstream("dmmeta.ctype:dev.Builddir"))
        assert "error" in result


class TestDeleteCtype:
    """Unit tests for delete_ctype tool."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_calls_acr_ed_delete_ctype(self):
        self.mock_client.acr_ed_delete_ctype.return_value = AcrResult(ok=True)
        result = json.loads(srv.delete_ctype("myns.MyStruct"))
        assert result["ok"] is True
        self.mock_client.acr_ed_delete_ctype.assert_called_once_with("myns.MyStruct")

    def test_propagates_error(self):
        self.mock_client.acr_ed_delete_ctype.return_value = AcrResult(
            ok=False, stderr="ctype not found", returncode=1
        )
        result = json.loads(srv.delete_ctype("bad.Type"))
        assert result["ok"] is False

    def test_no_client(self):
        srv._client = None
        result = json.loads(srv.delete_ctype("myns.X"))
        assert "error" in result


class TestDeleteField:
    """Unit tests for delete_field tool."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_calls_acr_ed_delete_field(self):
        self.mock_client.acr_ed_delete_field.return_value = AcrResult(ok=True)
        result = json.loads(srv.delete_field("myns.MyStruct.my_field"))
        assert result["ok"] is True
        self.mock_client.acr_ed_delete_field.assert_called_once_with("myns.MyStruct.my_field")

    def test_propagates_error(self):
        self.mock_client.acr_ed_delete_field.return_value = AcrResult(
            ok=False, stderr="field not found", returncode=1
        )
        result = json.loads(srv.delete_field("bad.Type.field"))
        assert result["ok"] is False


class TestDeleteTarget:
    """Unit tests for delete_target tool."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_calls_acr_ed_delete_target(self):
        self.mock_client.acr_ed_delete_target.return_value = AcrResult(ok=True)
        result = json.loads(srv.delete_target("myns"))
        assert result["ok"] is True
        self.mock_client.acr_ed_delete_target.assert_called_once_with("myns")

    def test_propagates_error(self):
        self.mock_client.acr_ed_delete_target.return_value = AcrResult(
            ok=False, stderr="target not found", returncode=1
        )
        result = json.loads(srv.delete_target("badns"))
        assert result["ok"] is False


class TestCreateSrcfile:
    """Unit tests for create_srcfile tool."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_calls_acr_ed_create_srcfile(self):
        self.mock_client.acr_ed_create_srcfile.return_value = AcrResult(ok=True)
        result = json.loads(srv.create_srcfile("myapp", "cpp/myapp/main.cpp"))
        assert result["ok"] is True
        self.mock_client.acr_ed_create_srcfile.assert_called_once_with(
            "cpp/myapp/main.cpp", "myapp"
        )

    def test_propagates_error(self):
        self.mock_client.acr_ed_create_srcfile.return_value = AcrResult(
            ok=False, stderr="target not found", returncode=1
        )
        result = json.loads(srv.create_srcfile("bad", "cpp/bad/x.cpp"))
        assert result["ok"] is False


class TestCreateUnittest:
    """Unit tests for create_unittest tool."""

    @pytest.fixture(autouse=True)
    def setup_mock_client(self):
        mock_client = MagicMock(spec=AcrClient)
        srv._client = mock_client
        self.mock_client = mock_client
        yield
        srv._client = None

    def test_calls_acr_ed_create_unittest(self):
        self.mock_client.acr_ed_create_unittest.return_value = AcrResult(ok=True)
        result = json.loads(srv.create_unittest("atf_ut", "TestAdd", "Test addition"))
        assert result["ok"] is True
        self.mock_client.acr_ed_create_unittest.assert_called_once_with(
            "atf_ut.TestAdd", "Test addition"
        )

    def test_propagates_error(self):
        self.mock_client.acr_ed_create_unittest.return_value = AcrResult(
            ok=False, stderr="target not found", returncode=1
        )
        result = json.loads(srv.create_unittest("bad", "TestX"))
        assert result["ok"] is False

    def test_no_comment(self):
        self.mock_client.acr_ed_create_unittest.return_value = AcrResult(ok=True)
        srv.create_unittest("atf_ut", "TestSomething")
        self.mock_client.acr_ed_create_unittest.assert_called_once_with(
            "atf_ut.TestSomething", ""
        )


@skip_no_openacr
class TestGetUsageExamples:
    """Integration tests for get_usage_examples tool."""

    @pytest.fixture(autouse=True)
    def setup_client(self):
        srv._client = AcrClient(OPENACR_DIR)
        yield
        srv._client = None

    def test_returns_valid_json(self):
        result = json.loads(srv.get_usage_examples("dev"))
        assert result["namespace"] == "dev"
        assert "include" in result
        assert "dev_gen.h" in result["include"]
        assert len(result["types"]) > 0

    def test_enum_has_code_examples(self):
        result = json.loads(srv.get_usage_examples("dev"))
        enums = [t for t in result["types"] if t["is_enum"]]
        assert len(enums) > 0
        mdmark = next((t for t in enums if t["type_name"] == "Mdmark"), None)
        assert mdmark is not None
        assert len(mdmark["code"]) >= 2
        assert len(mdmark["enum_values"]) >= 2
        # Check code contains GetEnum / SetEnum / ToCstr patterns
        all_code = " ".join(c["cpp"] for c in mdmark["code"])
        assert "GetEnum" in all_code
        assert "SetEnum" in all_code
        assert "ToCstr" in all_code

    def test_struct_has_code_examples(self):
        result = json.loads(srv.get_usage_examples("dev"))
        structs = [t for t in result["types"] if not t["is_enum"]]
        assert len(structs) > 0
        builddir = next((t for t in structs if t["type_name"] == "Builddir"), None)
        assert builddir is not None
        assert len(builddir["code"]) >= 2
        assert "fields" in builddir
        # Check code contains Init and field assignment
        all_code = " ".join(c["cpp"] for c in builddir["code"])
        assert "Builddir_Init" in all_code
        assert "rec." in all_code

    def test_struct_fk_fields_shown(self):
        result = json.loads(srv.get_usage_examples("dev"))
        builddir = next((t for t in result["types"] if t["type_name"] == "Builddir"), None)
        assert builddir is not None
        # FK fields should show "FK to" in the code
        create_code = builddir["code"][0]["cpp"]
        assert "FK to" in create_code

    def test_unknown_namespace(self):
        result = json.loads(srv.get_usage_examples("nonexistent_ns"))
        assert "error" in result

    def test_skips_internal_types(self):
        result = json.loads(srv.get_usage_examples("dev"))
        type_names = [t["type_name"] for t in result["types"]]
        assert "FieldId" not in type_names
        assert not any(n.endswith("Case") for n in type_names)
